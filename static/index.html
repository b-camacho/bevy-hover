<html> <head>
    <title>bevy-hover example</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.27.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <style>
body {
    font-family: mono;
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    background-color: #2c2d30; /* Dark background */
    color: #ffffff; /* Light text color */
}

#wrapper {
    display: flex;
    flex-direction: column;
}

#title {
    font-size: 24px;
    margin-bottom: 20px;
}

#bevy, #code {
    margin-bottom: 20px;
}

#bevy {
    height: 300px;
}

#code {
    border: 1px solid #333333; /* Darker border */
    border-radius: 0.5em;
    padding: 10px;
    background-color: #1e1e1e; /* Darker background for code panel */
    overflow: auto;
    font-family: 'Courier New', monospace; /* Monospace font for code */
    color: #dcdcdc; /* Light gray color for code */
}

@media (max-width: 600px) {
    /* Adjustments for narrow screens */
    body {
        align-items: stretch;
    }

    #bevy, #code {
        width: auto; /* Full width on narrow screens */
        margin: 10px;
    }
}

    </style>
</head>
<body>
    <div id="title">bevy-hover example</div>
    <div id="wrapper">
    <canvas id="bevy"></canvas>
    <pre id="code"><code class="language-rust">use bevy::core_pipeline::bloom::BloomSettings;
use bevy::core_pipeline::tonemapping::Tonemapping;
use bevy::prelude::*;
use bevy::window::WindowResolution;
use std::f32::consts::PI;

mod hover;

#[derive(Resource)]
struct SphereRotVel {
    pub vel: Quat, // Sphere rotates by the `vel` quat each second
}

#[derive(Component)]
struct SphereRot {}

fn sphere_rot(
    res_vel: Res<SphereRotVel>,
    mut transform: Query<&mut Transform, With<SphereRot>>,
    time: Res<Time>,
) {
    let delta = time.delta().as_secs_f32();
    let rot = res_vel.vel;
    let rot_scaled = {
        let (plane, angle) = rot.to_axis_angle();
        let angle_scaled = angle.map((0.0, PI), (0.0, PI * delta));
        Quat::from_axis_angle(plane, angle_scaled)
    };

    for mut tr in transform.iter_mut() {
        tr.rotate(rot_scaled);
    }
}

fn setup(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    // ambient light
    commands.insert_resource(AmbientLight {
        color: Color::WHITE,
        brightness: 0.01,
    });

    commands.spawn(DirectionalLightBundle {
        directional_light: DirectionalLight {
            illuminance: 400.0,
            ..default()
        },
        ..default()
    });

    commands.insert_resource(SphereRotVel {
        vel: Quat::from_euler(EulerRot::ZYX, 0.1, 0.1, 0.0),
    });

    let mut sphere = commands.spawn(TransformBundle::default());
    sphere.insert(SphereRot {});
    let sid = sphere.id();

    let mut ids = Vec::new();
    for idx in 0..80 {
        let mesh = asset_server.load(format!("ico.glb#Mesh{idx}/Primitive0"));
        let map_from_idx = |to_range| {
            let (to_start, to_end) = to_range;
            return (idx as f32).map((0.0, 80.0), (to_start, to_end));
        };
        let l = map_from_idx((0.6, 0.8));
        let h = map_from_idx((0.0, 360.0));
        let material = materials.add(StandardMaterial {
            base_color: Color::GRAY.with_l(l),
            ..default()
        });

        let mut seg = commands.spawn(PbrBundle {
            mesh,
            material,
            ..default()
        });
        let hover_material = materials.add(StandardMaterial {
            base_color: Color::hsla(h, 0.5, l, 1.0),
            emissive: Color::hsla(h, 0.5, l, 1.0),
            ..default()
        });
        ids.push(seg.id());
        seg.insert(hover::Hoverable {
            material: Some(hover_material),
        });
    }

    commands.entity(sid).push_children(&ids);

    // camera
    commands
        .spawn((
            Camera3dBundle {
                camera: Camera {
                    hdr: true,
                    ..default()
                },
                transform: Transform::from_xyz(0.0, 0.0, 3.0),
                tonemapping: Tonemapping::TonyMcMapface,
                ..Default::default()
            },
            BloomSettings {
                intensity: 0.2,
                ..default()
            },
        ))
        .insert(hover::MouseRaySource);
}

fn main() {
    App::new()
        .add_plugins(
            DefaultPlugins
                .set(WindowPlugin {
                    primary_window: Some(Window {
                        resolution: WindowResolution::new(640f32, 640f32),
                        canvas: Some("#bevy".to_owned()),
                        ..default()
                    }),
                    ..default()
                })
                .build(),
        )
        //.add_plugins(WorldInspectorPlugin::default())
        .add_systems(Startup, setup)
        .add_systems(Update, sphere_rot)
        .add_plugins(hover::MouseRayPlugin)
        .run();
}

pub trait MapRange {
    type Num;
    fn map(&self, src: (Self::Num, Self::Num), dst: (Self::Num, Self::Num)) -> Self::Num;
}

impl MapRange for f32 {
    type Num = f32;
    fn map(&self, src: (f32, f32), dst: (f32, f32)) -> f32 {
        if src.0 == src.1 {
            return dst.0; // avoid div by 0
        }
        let m = (dst.1 - dst.0) / (src.1 - src.0);
        let b = ((dst.0 * src.1) - (dst.1 * src.0)) / (src.1 - src.0);
        // y = mx+b
        (self * m) + b
    }
}
    </code></pre>
    </div>
  <script type="module">
    import init from './bevy-hover.js'
    init()
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.27.0/components/prism-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.27.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>


